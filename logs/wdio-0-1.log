2021-10-30T16:05:26.492Z INFO @wdio/local-runner: Run worker command: run
2021-10-30T16:05:29.860Z INFO webdriver: Initiate new session using the WebDriver protocol
2021-10-30T16:05:29.923Z INFO webdriver: [POST] http://34.72.180.106:4444/session
2021-10-30T16:05:29.923Z INFO webdriver: DATA {
  capabilities: {
    alwaysMatch: { browserName: 'chrome', acceptInsecureCerts: true },
    firstMatch: [ {} ]
  },
  desiredCapabilities: { browserName: 'chrome', acceptInsecureCerts: true }
}
2021-10-30T16:05:38.227Z INFO webdriver: COMMAND navigateTo("https://www.volvocars.com/intl/v/car-safety/a-million-more")
2021-10-30T16:05:38.228Z INFO webdriver: [POST] http://34.72.180.106:4444/session/b908a3ddbdfa97419ea9a0691fa6d285/url
2021-10-30T16:05:38.228Z INFO webdriver: DATA { url: 'https://www.volvocars.com/intl/v/car-safety/a-million-more' }
2021-10-30T16:05:40.020Z INFO webdriver: COMMAND maximizeWindow()
2021-10-30T16:05:40.020Z INFO webdriver: [POST] http://34.72.180.106:4444/session/b908a3ddbdfa97419ea9a0691fa6d285/window/maximize
2021-10-30T16:05:40.341Z INFO webdriver: RESULT { height: 998, width: 1360, x: 0, y: 0 }
2021-10-30T16:05:43.345Z INFO webdriver: COMMAND findElement("xpath", "/html/body/div[1]/div[2]/div[4]/div[2]/div/button")
2021-10-30T16:05:43.345Z INFO webdriver: [POST] http://34.72.180.106:4444/session/b908a3ddbdfa97419ea9a0691fa6d285/element
2021-10-30T16:05:43.345Z INFO webdriver: DATA {
  using: 'xpath',
  value: '/html/body/div[1]/div[2]/div[4]/div[2]/div/button'
}
2021-10-30T16:05:43.587Z INFO webdriver: RESULT {
  'element-6066-11e4-a52e-4f735466cecf': 'aa7eaec0-6322-4d2b-b46e-7944055b4803'
}
2021-10-30T16:05:43.595Z INFO webdriver: COMMAND elementClick("aa7eaec0-6322-4d2b-b46e-7944055b4803")
2021-10-30T16:05:43.596Z INFO webdriver: [POST] http://34.72.180.106:4444/session/b908a3ddbdfa97419ea9a0691fa6d285/element/aa7eaec0-6322-4d2b-b46e-7944055b4803/click
2021-10-30T16:05:44.468Z INFO webdriver: COMMAND findElement("xpath", "//*[@id="ProductListCarousel-1"]/section/div[1]/div/div/div/div[3]")
2021-10-30T16:05:44.468Z INFO webdriver: [POST] http://34.72.180.106:4444/session/b908a3ddbdfa97419ea9a0691fa6d285/element
2021-10-30T16:05:44.468Z INFO webdriver: DATA {
  using: 'xpath',
  value: '//*[@id="ProductListCarousel-1"]/section/div[1]/div/div/div/div[3]'
}
2021-10-30T16:05:44.470Z INFO webdriver: COMMAND findElement("xpath", "//a[text()='Mild hybrid cars']")
2021-10-30T16:05:44.470Z INFO webdriver: [POST] http://34.72.180.106:4444/session/b908a3ddbdfa97419ea9a0691fa6d285/element
2021-10-30T16:05:44.470Z INFO webdriver: DATA { using: 'xpath', value: "//a[text()='Mild hybrid cars']" }
2021-10-30T16:05:44.804Z INFO webdriver: RESULT {
  'element-6066-11e4-a52e-4f735466cecf': 'e744cc62-b592-4262-80f0-f113c90c3993'
}
2021-10-30T16:05:44.810Z INFO webdriver: COMMAND executeScript(<fn>, <object>)
2021-10-30T16:05:44.810Z INFO webdriver: [POST] http://34.72.180.106:4444/session/b908a3ddbdfa97419ea9a0691fa6d285/execute/sync
2021-10-30T16:05:44.810Z INFO webdriver: DATA {
  script: 'return (function (elem, options) {\n' +
    '        elem.scrollIntoView(options);\n' +
    '    }).apply(null, arguments)',
  args: [
    {
      'element-6066-11e4-a52e-4f735466cecf': 'e744cc62-b592-4262-80f0-f113c90c3993',
      ELEMENT: 'e744cc62-b592-4262-80f0-f113c90c3993'
    },
    true
  ]
}
2021-10-30T16:05:46.226Z INFO webdriver: RESULT {
  'element-6066-11e4-a52e-4f735466cecf': '3c802f75-bf9a-4361-913c-f3a9bac1ba53'
}
2021-10-30T16:05:46.515Z INFO webdriver: COMMAND executeScript(<fn>, <object>)
2021-10-30T16:05:46.516Z INFO webdriver: [POST] http://34.72.180.106:4444/session/b908a3ddbdfa97419ea9a0691fa6d285/execute/sync
2021-10-30T16:05:46.516Z INFO webdriver: DATA {
  script: 'return (function isElementDisplayed(element) {\n' +
    '    function nodeIsElement(node) {\n' +
    '        if (!node) {\n' +
    '            return false;\n' +
    '        }\n' +
    '        switch (node.nodeType) {\n' +
    '            case Node.ELEMENT_NODE:\n' +
    '            case Node.DOCUMENT_NODE:\n' +
    '            case Node.DOCUMENT_FRAGMENT_NODE:\n' +
    '                return true;\n' +
    '            default:\n' +
    '                return false;\n' +
    '        }\n' +
    '    }\n' +
    '    function parentElementForElement(element) {\n' +
    '        if (!element) {\n' +
    '            return null;\n' +
    '        }\n' +
    '        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n' +
    '    }\n' +
    '    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n' +
    '        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n' +
    '            if (predicate(node)) {\n' +
    '                return node;\n' +
    '            }\n' +
    '        return null;\n' +
    '    }\n' +
    '    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n' +
    '        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n' +
    '            if (predicate(element)) {\n' +
    '                return element;\n' +
    '            }\n' +
    '        return null;\n' +
    '    }\n' +
    '    function cascadedStylePropertyForElement(element, property) {\n' +
    '        if (!element || !property) {\n' +
    '            return null;\n' +
    '        }\n' +
    '        // if document-fragment, skip it and use element.host instead. This happens\n' +
    '        // when the element is inside a shadow root.\n' +
    '        // window.getComputedStyle errors on document-fragment.\n' +
    '        if (element instanceof DocumentFragment) {\n' +
    '            element = element.host;\n' +
    '        }\n' +
    '        let computedStyle = window.getComputedStyle(element);\n' +
    '        let computedStyleProperty = computedStyle.getPropertyValue(property);\n' +
    "        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n" +
    '            return computedStyleProperty;\n' +
    '        }\n' +
    "        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n" +
    "        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n" +
    "        // Fall back to the first non-'inherit' value found in an ancestor.\n" +
    "        // In any case, getPropertyValue will not return 'initial'.\n" +
    '        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n' +
    '        // I think all important non-inheritable properties (width, height, etc.)\n' +
    '        // for our purposes here are specially resolved, so this may not be an issue.\n' +
    '        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n' +
    '        let parentElement = parentElementForElement(element);\n' +
    '        return cascadedStylePropertyForElement(parentElement, property);\n' +
    '    }\n' +
    '    function elementSubtreeHasNonZeroDimensions(element) {\n' +
    '        let boundingBox = element.getBoundingClientRect();\n' +
    '        if (boundingBox.width > 0 && boundingBox.height > 0) {\n' +
    '            return true;\n' +
    '        }\n' +
    '        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n' +
    "        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n" +
    "            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n" +
    '            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n' +
    '        }\n' +
    "        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n" +
    "        if (cascadedOverflow === 'hidden') {\n" +
    '            return false;\n' +
    '        }\n' +
    "        // If the container's overflow is not hidden and it has zero size, consider the\n" +
    '        // container to have non-zero dimensions if a child node has non-zero dimensions.\n' +
    '        return Array.from(element.childNodes).some((childNode) => {\n' +
    '            if (childNode.nodeType === Node.TEXT_NODE) {\n' +
    '                return true;\n' +
    '            }\n' +
    '            if (nodeIsElement(childNode)) {\n' +
    '                return elementSubtreeHasNonZeroDimensions(childNode);\n' +
    '            }\n' +
    '            return false;\n' +
    '        });\n' +
    '    }\n' +
    '    function elementOverflowsContainer(element) {\n' +
    "        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n" +
    "        if (cascadedOverflow !== 'hidden') {\n" +
    '            return false;\n' +
    '        }\n' +
    '        // FIXME: this needs to take into account the scroll position of the element,\n' +
    '        // the display modes of it and its ancestors, and the container it overflows.\n' +
    "        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n" +
    '        return true;\n' +
    '    }\n' +
    '    function isElementSubtreeHiddenByOverflow(element) {\n' +
    '        if (!element) {\n' +
    '            return false;\n' +
    '        }\n' +
    '        if (!elementOverflowsContainer(element)) {\n' +
    '            return false;\n' +
    '        }\n' +
    '        if (!element.childNodes.length) {\n' +
    '            return false;\n' +
    '        }\n' +
    "        // This element's subtree is hidden by overflow if all child subtrees are as well.\n" +
    '        return Array.from(element.childNodes).every((childNode) => {\n' +
    '            // Returns true if the child node is overflowed or otherwise hidden.\n' +
    "            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n" +
    '            // Visibility of text nodes is controlled by parent\n' +
    '            if (childNode.nodeType === Node.TEXT_NODE) {\n' +
    '                return false;\n' +
    '            }\n' +
    '            if (!nodeIsElement(childNode)) {\n' +
    '                return true;\n' +
    '            }\n' +
    '            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n' +
    '                return true;\n' +
    '            }\n' +
    '            // Recurse.\n' +
    '            return isElementSubtreeHiddenByOverflow(childNode);\n' +
    '        });\n' +
    '    }\n' +
    '    // walk up the tree testing for a shadow root\n' +
    '    function isElementInsideShadowRoot(element) {\n' +
    '        if (!element) {\n' +
    '            return false;\n' +
    '        }\n' +
    '        if (element.parentNode && element.parentNode.host) {\n' +
    '            return true;\n' +
    '        }\n' +
    '        return isElementInsideShadowRoot(element.parentNode);\n' +
    '    }\n' +
    `    // This is a partial reimplementation of Selenium's "element is displayed" algorithm.\n` +
    "    // When the W3C specification's algorithm stabilizes, we should implement that.\n" +
    '    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n' +
    '    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n' +
    '        return false;\n' +
    '    }\n' +
    '    // Special cases for specific tag names.\n' +
    '    switch (element.tagName.toUpperCase()) {\n' +
    "        case 'BODY':\n" +
    '            return true;\n' +
    "        case 'SCRIPT':\n" +
    "        case 'NOSCRIPT':\n" +
    '            return false;\n' +
    "        case 'OPTGROUP':\n" +
    "        case 'OPTION': {\n" +
    '            // Option/optgroup are considered shown if the containing <select> is shown.\n' +
    "            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n" +
    '            return isElementDisplayed(enclosingSelectElement);\n' +
    '        }\n' +
    "        case 'INPUT':\n" +
    '            // <input type="hidden"> is considered not shown.\n' +
    "            if (element.type === 'hidden') {\n" +
    '                return false;\n' +
    '            }\n' +
    '            break;\n' +
    "        // case 'MAP':\n" +
    "        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n" +
    '        default:\n' +
    '            break;\n' +
    '    }\n' +
    "    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n" +
    '        return false;\n' +
    '    }\n' +
    '    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n' +
    "        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n" +
    '    });\n' +
    '    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n' +
    "        return cascadedStylePropertyForElement(e, 'display') === 'none';\n" +
    '    });\n' +
    '    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n' +
    '        return false;\n' +
    '    }\n' +
    '    if (!elementSubtreeHasNonZeroDimensions(element)) {\n' +
    '        return false;\n' +
    '    }\n' +
    '    if (isElementSubtreeHiddenByOverflow(element)) {\n' +
    '        return false;\n' +
    '    }\n' +
    '    return true;\n' +
    '}).apply(null, arguments)',
  args: [
    {
      'element-6066-11e4-a52e-4f735466cecf': '3c802f75-bf9a-4361-913c-f3a9bac1ba53',
      ELEMENT: '3c802f75-bf9a-4361-913c-f3a9bac1ba53'
    }
  ]
}
2021-10-30T16:05:47.558Z WARN webdriver: Request encountered a stale element - terminating request
2021-10-30T16:05:47.559Z INFO webdriver: COMMAND findElement("xpath", "//a[text()='Mild hybrid cars']")
2021-10-30T16:05:47.560Z INFO webdriver: [POST] http://34.72.180.106:4444/session/b908a3ddbdfa97419ea9a0691fa6d285/element
2021-10-30T16:05:47.560Z INFO webdriver: DATA { using: 'xpath', value: "//a[text()='Mild hybrid cars']" }
2021-10-30T16:05:47.842Z INFO webdriver: RESULT {
  'element-6066-11e4-a52e-4f735466cecf': '314aeae4-d9c7-41df-997c-70d746bbae30'
}
2021-10-30T16:05:47.846Z INFO webdriver: COMMAND executeScript(<fn>, <object>)
2021-10-30T16:05:47.846Z INFO webdriver: [POST] http://34.72.180.106:4444/session/b908a3ddbdfa97419ea9a0691fa6d285/execute/sync
2021-10-30T16:05:47.846Z INFO webdriver: DATA {
  script: 'return (function isElementDisplayed(element) {\n' +
    '    function nodeIsElement(node) {\n' +
    '        if (!node) {\n' +
    '            return false;\n' +
    '        }\n' +
    '        switch (node.nodeType) {\n' +
    '            case Node.ELEMENT_NODE:\n' +
    '            case Node.DOCUMENT_NODE:\n' +
    '            case Node.DOCUMENT_FRAGMENT_NODE:\n' +
    '                return true;\n' +
    '            default:\n' +
    '                return false;\n' +
    '        }\n' +
    '    }\n' +
    '    function parentElementForElement(element) {\n' +
    '        if (!element) {\n' +
    '            return null;\n' +
    '        }\n' +
    '        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n' +
    '    }\n' +
    '    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n' +
    '        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n' +
    '            if (predicate(node)) {\n' +
    '                return node;\n' +
    '            }\n' +
    '        return null;\n' +
    '    }\n' +
    '    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n' +
    '        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n' +
    '            if (predicate(element)) {\n' +
    '                return element;\n' +
    '            }\n' +
    '        return null;\n' +
    '    }\n' +
    '    function cascadedStylePropertyForElement(element, property) {\n' +
    '        if (!element || !property) {\n' +
    '            return null;\n' +
    '        }\n' +
    '        // if document-fragment, skip it and use element.host instead. This happens\n' +
    '        // when the element is inside a shadow root.\n' +
    '        // window.getComputedStyle errors on document-fragment.\n' +
    '        if (element instanceof DocumentFragment) {\n' +
    '            element = element.host;\n' +
    '        }\n' +
    '        let computedStyle = window.getComputedStyle(element);\n' +
    '        let computedStyleProperty = computedStyle.getPropertyValue(property);\n' +
    "        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n" +
    '            return computedStyleProperty;\n' +
    '        }\n' +
    "        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n" +
    "        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n" +
    "        // Fall back to the first non-'inherit' value found in an ancestor.\n" +
    "        // In any case, getPropertyValue will not return 'initial'.\n" +
    '        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n' +
    '        // I think all important non-inheritable properties (width, height, etc.)\n' +
    '        // for our purposes here are specially resolved, so this may not be an issue.\n' +
    '        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n' +
    '        let parentElement = parentElementForElement(element);\n' +
    '        return cascadedStylePropertyForElement(parentElement, property);\n' +
    '    }\n' +
    '    function elementSubtreeHasNonZeroDimensions(element) {\n' +
    '        let boundingBox = element.getBoundingClientRect();\n' +
    '        if (boundingBox.width > 0 && boundingBox.height > 0) {\n' +
    '            return true;\n' +
    '        }\n' +
    '        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n' +
    "        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n" +
    "            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n" +
    '            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n' +
    '        }\n' +
    "        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n" +
    "        if (cascadedOverflow === 'hidden') {\n" +
    '            return false;\n' +
    '        }\n' +
    "        // If the container's overflow is not hidden and it has zero size, consider the\n" +
    '        // container to have non-zero dimensions if a child node has non-zero dimensions.\n' +
    '        return Array.from(element.childNodes).some((childNode) => {\n' +
    '            if (childNode.nodeType === Node.TEXT_NODE) {\n' +
    '                return true;\n' +
    '            }\n' +
    '            if (nodeIsElement(childNode)) {\n' +
    '                return elementSubtreeHasNonZeroDimensions(childNode);\n' +
    '            }\n' +
    '            return false;\n' +
    '        });\n' +
    '    }\n' +
    '    function elementOverflowsContainer(element) {\n' +
    "        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n" +
    "        if (cascadedOverflow !== 'hidden') {\n" +
    '            return false;\n' +
    '        }\n' +
    '        // FIXME: this needs to take into account the scroll position of the element,\n' +
    '        // the display modes of it and its ancestors, and the container it overflows.\n' +
    "        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n" +
    '        return true;\n' +
    '    }\n' +
    '    function isElementSubtreeHiddenByOverflow(element) {\n' +
    '        if (!element) {\n' +
    '            return false;\n' +
    '        }\n' +
    '        if (!elementOverflowsContainer(element)) {\n' +
    '            return false;\n' +
    '        }\n' +
    '        if (!element.childNodes.length) {\n' +
    '            return false;\n' +
    '        }\n' +
    "        // This element's subtree is hidden by overflow if all child subtrees are as well.\n" +
    '        return Array.from(element.childNodes).every((childNode) => {\n' +
    '            // Returns true if the child node is overflowed or otherwise hidden.\n' +
    "            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n" +
    '            // Visibility of text nodes is controlled by parent\n' +
    '            if (childNode.nodeType === Node.TEXT_NODE) {\n' +
    '                return false;\n' +
    '            }\n' +
    '            if (!nodeIsElement(childNode)) {\n' +
    '                return true;\n' +
    '            }\n' +
    '            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n' +
    '                return true;\n' +
    '            }\n' +
    '            // Recurse.\n' +
    '            return isElementSubtreeHiddenByOverflow(childNode);\n' +
    '        });\n' +
    '    }\n' +
    '    // walk up the tree testing for a shadow root\n' +
    '    function isElementInsideShadowRoot(element) {\n' +
    '        if (!element) {\n' +
    '            return false;\n' +
    '        }\n' +
    '        if (element.parentNode && element.parentNode.host) {\n' +
    '            return true;\n' +
    '        }\n' +
    '        return isElementInsideShadowRoot(element.parentNode);\n' +
    '    }\n' +
    `    // This is a partial reimplementation of Selenium's "element is displayed" algorithm.\n` +
    "    // When the W3C specification's algorithm stabilizes, we should implement that.\n" +
    '    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n' +
    '    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n' +
    '        return false;\n' +
    '    }\n' +
    '    // Special cases for specific tag names.\n' +
    '    switch (element.tagName.toUpperCase()) {\n' +
    "        case 'BODY':\n" +
    '            return true;\n' +
    "        case 'SCRIPT':\n" +
    "        case 'NOSCRIPT':\n" +
    '            return false;\n' +
    "        case 'OPTGROUP':\n" +
    "        case 'OPTION': {\n" +
    '            // Option/optgroup are considered shown if the containing <select> is shown.\n' +
    "            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n" +
    '            return isElementDisplayed(enclosingSelectElement);\n' +
    '        }\n' +
    "        case 'INPUT':\n" +
    '            // <input type="hidden"> is considered not shown.\n' +
    "            if (element.type === 'hidden') {\n" +
    '                return false;\n' +
    '            }\n' +
    '            break;\n' +
    "        // case 'MAP':\n" +
    "        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n" +
    '        default:\n' +
    '            break;\n' +
    '    }\n' +
    "    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n" +
    '        return false;\n' +
    '    }\n' +
    '    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n' +
    "        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n" +
    '    });\n' +
    '    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n' +
    "        return cascadedStylePropertyForElement(e, 'display') === 'none';\n" +
    '    });\n' +
    '    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n' +
    '        return false;\n' +
    '    }\n' +
    '    if (!elementSubtreeHasNonZeroDimensions(element)) {\n' +
    '        return false;\n' +
    '    }\n' +
    '    if (isElementSubtreeHiddenByOverflow(element)) {\n' +
    '        return false;\n' +
    '    }\n' +
    '    return true;\n' +
    '}).apply(null, arguments)',
  args: [
    {
      'element-6066-11e4-a52e-4f735466cecf': '314aeae4-d9c7-41df-997c-70d746bbae30',
      ELEMENT: '314aeae4-d9c7-41df-997c-70d746bbae30'
    }
  ]
}
2021-10-30T16:05:48.133Z INFO webdriver: RESULT true
2021-10-30T16:05:48.138Z INFO webdriver: COMMAND elementClick("314aeae4-d9c7-41df-997c-70d746bbae30")
2021-10-30T16:05:48.138Z INFO webdriver: [POST] http://34.72.180.106:4444/session/b908a3ddbdfa97419ea9a0691fa6d285/element/314aeae4-d9c7-41df-997c-70d746bbae30/click
2021-10-30T16:05:49.894Z INFO webdriver: COMMAND getUrl()
2021-10-30T16:05:49.894Z INFO webdriver: [GET] http://34.72.180.106:4444/session/b908a3ddbdfa97419ea9a0691fa6d285/url
2021-10-30T16:05:50.452Z INFO webdriver: RESULT https://www.volvocars.com/intl/v/cars/other-powertrains
2021-10-30T16:05:50.456Z INFO webdriver: COMMAND findElement("xpath", "//*[@id="ModelTitle-1"]/section/div/div/div/h1")
2021-10-30T16:05:50.456Z INFO webdriver: [POST] http://34.72.180.106:4444/session/b908a3ddbdfa97419ea9a0691fa6d285/element
2021-10-30T16:05:50.456Z INFO webdriver: DATA {
  using: 'xpath',
  value: '//*[@id="ModelTitle-1"]/section/div/div/div/h1'
}
2021-10-30T16:05:50.720Z INFO webdriver: RESULT {
  'element-6066-11e4-a52e-4f735466cecf': 'c3b87d97-4459-47ba-91f9-b10442d8dea5'
}
2021-10-30T16:05:50.727Z INFO webdriver: COMMAND getElementText("c3b87d97-4459-47ba-91f9-b10442d8dea5")
2021-10-30T16:05:50.728Z INFO webdriver: [GET] http://34.72.180.106:4444/session/b908a3ddbdfa97419ea9a0691fa6d285/element/c3b87d97-4459-47ba-91f9-b10442d8dea5/text
2021-10-30T16:05:50.975Z INFO webdriver: RESULT Mild hybrids
2021-10-30T16:05:50.989Z INFO webdriver: COMMAND getLogTypes()
2021-10-30T16:05:50.989Z INFO webdriver: [GET] http://34.72.180.106:4444/session/b908a3ddbdfa97419ea9a0691fa6d285/se/log/types
2021-10-30T16:05:51.219Z INFO webdriver: RESULT [ 'browser', 'driver' ]
2021-10-30T16:05:51.219Z INFO webdriver: COMMAND getLogs("driver")
2021-10-30T16:05:51.220Z INFO webdriver: [POST] http://34.72.180.106:4444/session/b908a3ddbdfa97419ea9a0691fa6d285/se/log
2021-10-30T16:05:51.220Z INFO webdriver: DATA { type: 'driver' }
2021-10-30T16:05:51.220Z INFO webdriver: COMMAND getLogs("browser")
2021-10-30T16:05:51.221Z INFO webdriver: [POST] http://34.72.180.106:4444/session/b908a3ddbdfa97419ea9a0691fa6d285/se/log
2021-10-30T16:05:51.221Z INFO webdriver: DATA { type: 'browser' }
2021-10-30T16:05:51.482Z INFO webdriver: RESULT []
2021-10-30T16:05:51.483Z INFO webdriver: RESULT []
2021-10-30T16:05:51.484Z INFO webdriver: COMMAND deleteSession()
2021-10-30T16:05:51.484Z INFO webdriver: [DELETE] http://34.72.180.106:4444/session/b908a3ddbdfa97419ea9a0691fa6d285
